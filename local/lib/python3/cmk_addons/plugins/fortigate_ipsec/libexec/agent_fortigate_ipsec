#!/usr/bin/env python3
"""Special agent for FortiGate IPsec tunnel monitoring."""

from __future__ import annotations

import argparse
import json
import sys
import time
from typing import Any, Dict, Iterable, List, Optional

import requests
from requests import Response
from requests.exceptions import HTTPError, RequestException

API_PATH = "/api/v2/monitor/vpn/ipsec"


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Fetch FortiGate IPsec tunnel status via REST API")
    parser.add_argument("--hostname", required=True, help="FortiGate management IP or hostname")
    parser.add_argument("--api-key", required=True, help="FortiGate API token")
    parser.add_argument("--port", type=int, default=443, help="FortiGate API HTTPS port")
    parser.add_argument("--no-cert-check", action="store_true", help="Disable TLS certificate verification")
    parser.add_argument("--vdom", help="Optional VDOM to query")
    parser.add_argument("--tunnel", help="Restrict the query to a single tunnel name")
    parser.add_argument(
        "--filter",
        action="append",
        default=[],
        help="Optional FortiOS API filter (key[@]=value). Repeat to add multiple filters.",
    )
    return parser.parse_args()


def _compact_dict(values: Dict[str, Any]) -> Dict[str, Any]:
    return {key: value for key, value in values.items() if value not in (None, "", [], {})}


def _coerce_int(value: Any) -> Optional[int]:
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return int(value)
    if value in (None, ""):
        return None
    try:
        return int(str(value), 10)
    except (TypeError, ValueError):
        try:
            return int(float(str(value)))
        except (TypeError, ValueError):
            return None


def _coerce_bool(value: Any) -> Optional[bool]:
    if isinstance(value, bool):
        return value
    if value in (None, ""):
        return None
    if isinstance(value, (int, float)):
        return bool(value)
    if isinstance(value, str):
        lowered = value.strip().lower()
        if lowered in {"true", "yes", "1"}:
            return True
        if lowered in {"false", "no", "0"}:
            return False
    return None


def _coerce_str(value: Any) -> Optional[str]:
    if value is None:
        return None
    result = str(value).strip()
    return result or None


def _normalize_endpoints(entries: Any) -> List[Dict[str, Any]]:
    endpoints: List[Dict[str, Any]] = []
    if not isinstance(entries, list):
        return endpoints
    for entry in entries:
        if not isinstance(entry, dict):
            continue
        normalized = _compact_dict(
            {
                "subnet": _coerce_str(entry.get("subnet")),
                "port": _coerce_int(entry.get("port")),
                "protocol": _coerce_int(entry.get("protocol")),
                "protocol_name": _coerce_str(entry.get("protocol_name")),
            }
        )
        if normalized:
            endpoints.append(normalized)
    return endpoints


def _normalize_proxy(proxy: Any) -> Optional[Dict[str, Any]]:
    if not isinstance(proxy, dict):
        return None
    normalized = {
        "status": _coerce_str(proxy.get("status")),
        "p2name": _coerce_str(proxy.get("p2name")),
        "dialup_index": _coerce_int(proxy.get("dialup_index")),
        "p2serial": _coerce_int(proxy.get("p2serial")),
        "expire": _coerce_int(proxy.get("expire")),
        "incoming_bytes": _coerce_int(
            proxy.get("incoming_bytes")
            or proxy.get("rx_bytes")
            or proxy.get("inbound_bytes"),
        ),
        "outgoing_bytes": _coerce_int(
            proxy.get("outgoing_bytes")
            or proxy.get("tx_bytes")
            or proxy.get("outbound_bytes"),
        ),
        "proxy_src": _normalize_endpoints(proxy.get("proxy_src") or proxy.get("proxy-src")),
        "proxy_dst": _normalize_endpoints(proxy.get("proxy_dst") or proxy.get("proxy-dst")),
    }
    normalized = _compact_dict(normalized)
    if not normalized:
        return None
    return normalized


def _aggregate_status(proxies: Iterable[Dict[str, Any]], fallback: Optional[str]) -> Optional[str]:
    statuses: List[str] = []
    for proxy in proxies:
        status = _coerce_str(proxy.get("status"))
        if status:
            statuses.append(status.lower())
    if not statuses:
        return _coerce_str(fallback)
    up = statuses.count("up")
    down = statuses.count("down")
    if up and not down:
        return "up"
    if not up and down:
        return "down"
    if up and down:
        return "mixed"
    return statuses[0]


def _prepare_tunnel(raw: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    name = _coerce_str(raw.get("name") or raw.get("tunnelname") or raw.get("phase2name"))
    if not name:
        return None

    proxies: List[Dict[str, Any]] = []
    raw_proxies = raw.get("proxyid") or raw.get("proxy-id")
    if isinstance(raw_proxies, list):
        for proxy in raw_proxies:
            normalized = _normalize_proxy(proxy)
            if normalized:
                proxies.append(normalized)

    tunnel = {
        "name": name,
        "status": _aggregate_status(proxies, _coerce_str(raw.get("status"))),
        "type": _coerce_str(raw.get("type")),
        "wizard_type": _coerce_str(raw.get("wizard-type")),
        "parent": _coerce_str(raw.get("parent")),
        "comments": _coerce_str(raw.get("comments")),
        "remote_gateway": _coerce_str(
            raw.get("rgwy") or raw.get("remote_gw") or raw.get("remote-gw"),
        ),
        "remote_port": _coerce_int(raw.get("rport")),
        "tunnel_id": _coerce_str(raw.get("tun_id")),
        "tunnel_id6": _coerce_str(raw.get("tun_id6")),
        "connection_count": _coerce_int(raw.get("connection_count")),
        "incoming_bytes": _coerce_int(
            raw.get("incoming_bytes")
            or raw.get("rx_bytes")
            or raw.get("inbound_bytes"),
        ),
        "outgoing_bytes": _coerce_int(
            raw.get("outgoing_bytes")
            or raw.get("tx_bytes")
            or raw.get("outbound_bytes"),
        ),
        "creation_time": _coerce_int(raw.get("creation_time")),
        "username": _coerce_str(raw.get("username")),
        "user": _coerce_str(raw.get("user")),
        "auth_type": _coerce_str(raw.get("auth_type")),
        "user_two_factor_auth": _coerce_bool(raw.get("user_two_factor_auth")),
        "is_ocvpn": _coerce_bool(raw.get("is_ocvpn")),
        "fct_uid": _coerce_str(raw.get("fct_uid")),
        "peer_sn": _coerce_str(raw.get("peer_sn")),
        "proxies": proxies,
    }

    return _compact_dict(tunnel)


def _build_params(vdom: Optional[str], filters: Iterable[str], tunnel: Optional[str]) -> Dict[str, Any]:
    params: Dict[str, Any] = {}
    if vdom:
        params["vdom"] = vdom
    filter_list: List[str] = [flt for flt in filters if flt]
    if filter_list:
        params["filter"] = filter_list
    if tunnel:
        params["tunnel"] = tunnel
    return params


def _request(url: str, headers: Dict[str, str], params: Dict[str, Any], verify: bool) -> Response:
    backoff = 1.0
    max_attempts = 5
    for attempt in range(1, max_attempts + 1):
        try:
            response = requests.get(url, headers=headers, params=params, timeout=15, verify=verify)
        except RequestException as exc:
            if attempt == max_attempts:
                raise RuntimeError(str(exc)) from exc
            time.sleep(backoff)
            backoff *= 2
            continue

        if response.status_code == 429:
            retry_after = response.headers.get("Retry-After")
            try:
                delay = float(retry_after)
            except (TypeError, ValueError):
                delay = backoff
            if attempt == max_attempts:
                raise RuntimeError("FortiGate API rate limit exceeded (HTTP 429)")
            time.sleep(max(delay, 1.0))
            backoff *= 2
            continue

        try:
            response.raise_for_status()
            return response
        except HTTPError as exc:
            if attempt == max_attempts:
                raise RuntimeError(str(exc)) from exc
            time.sleep(backoff)
            backoff *= 2
    raise RuntimeError("FortiGate API request failed after multiple retries")


def _extract_tunnels(payload: Any) -> Iterable[Dict[str, Any]]:
    if isinstance(payload, dict):
        results = payload.get("results")
        if isinstance(results, list):
            return results
        if "name" in payload:
            return [payload]
    if isinstance(payload, list):
        return payload
    return []


def main() -> int:
    args = _parse_args()

    url = f"https://{args.hostname}:{args.port}{API_PATH}"
    headers = {"Authorization": f"Bearer {args.api_key}"}
    verify = not args.no_cert_check

    print("<<<fortigate_ipsec:sep(0)>>>")

    if not verify:
        requests.packages.urllib3.disable_warnings()  # type: ignore[attr-defined]

    params = _build_params(args.vdom, args.filter, args.tunnel)

    try:
        response = _request(url, headers=headers, params=params, verify=verify)
        payload = response.json()
    except (RuntimeError, ValueError) as exc:
        print(f"ERROR {exc}")
        return 1

    for raw_tunnel in _extract_tunnels(payload):
        if not isinstance(raw_tunnel, dict):
            continue
        normalized = _prepare_tunnel(raw_tunnel)
        if not normalized:
            continue
        print(json.dumps(normalized, separators=(",", ":")))
    return 0

if __name__ == "__main__":
    sys.exit(main())




